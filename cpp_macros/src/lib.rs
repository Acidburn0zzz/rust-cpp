//! This crate is the `cpp` procedural macro implementation. It is useless
//! without the companion crates `cpp`, and `cpp_build`.
//!
//! For more information, see the [`cpp` crate module level
//! documentation](https://docs.rs/cpp).

extern crate cpp_synom as synom;

extern crate cpp_syn as syn;

#[macro_use]
extern crate quote;

extern crate cpp_common;

extern crate proc_macro;

#[macro_use]
extern crate lazy_static;

use std::env;
use std::path::PathBuf;
use std::process::Command;
use std::collections::HashMap;
use proc_macro::TokenStream;
use cpp_common::{parse_sizes_data, parsing};
use syn::Ident;

lazy_static! {
    static ref OUT_DIR: PathBuf =
        PathBuf::from(env::var("OUT_DIR").expect(r#"
-- rust-cpp fatal error --

The OUT_DIR environment variable was not set.
NOTE: rustc must be run by Cargo."#));

    static ref CPP_DIR: PathBuf = OUT_DIR.join("rust_cpp");

    static ref SIZE_DATA: HashMap<Ident, Vec<(usize, usize)>> = {
        let mut run_cmd = Command::new(CPP_DIR.join("print_sizes"));
        let output = run_cmd.output().expect(r#"
-- rust-cpp fatal error --

Failed to execute the `print_sizes` executable.
NOTE: Did you make sure to add the rust-cpp build script?"#);
        let stdout = String::from_utf8_lossy(&output.stdout);
        if !output.status.success() {
            panic!("Sizes executable has exited with non-zero status code");
        }

        parse_sizes_data(&stdout).into_iter().collect()
    };
}

/// Strip tokens from the prefix and suffix of the source string, extracting the
/// original argument to the cpp! macro.
fn macro_text(mut source: &str) -> &str {
    #[cfg_attr(rustfmt, rustfmt_skip)]
    const PREFIX: &'static [&'static str] = &[
        "#", "[", "allow", "(", "unused", ")", "]",
        "enum", "CppClosureInput", "{",
        "Input", "=", "(", "stringify", "!", "("
    ];

    #[cfg_attr(rustfmt, rustfmt_skip)]
    const SUFFIX: &'static [&'static str] = &[
        ")", ",", "0", ")", ".", "1", ",", "}"
    ];

    source = source.trim();

    for token in PREFIX {
        assert!(source.starts_with(token),
                "expected prefix token {}, got {}",
                token,
                source);
        source = &source[token.len()..].trim();
    }

    for token in SUFFIX.iter().rev() {
        assert!(source.ends_with(token),
                "expected suffix token {}, got {}",
                token,
                source);
        source = &source[..source.len() - token.len()].trim();
    }

    source
}

#[proc_macro_derive(__cpp_internal_closure)]
pub fn expand_internal(input: TokenStream) -> TokenStream {
    // Parse the macro input
    let source = input.to_string();
    let tokens = macro_text(&source);

    let closure = parsing::cpp_closure(synom::ParseState::new(tokens))
        .expect("cpp! macro")
        .sig;

    // Get the size data compiled by the build macro
    let size_data = SIZE_DATA
        .get(&closure.extern_name())
        .expect(r#"
-- rust-cpp fatal error --

This cpp! macro is not found in the print_sizes macro output!
NOTE: Only cpp! macros found directly in the program source will be parsed -
NOTE: They cannot be generated by macro expansion."#);

    let mut extern_params = Vec::new();
    let mut tt_args = Vec::new();
    let mut call_args = Vec::new();
    for (i, capture) in closure.captures.iter().enumerate() {
        let written_name = &capture.name;
        let mac_name: Ident = format!("$var_{}", written_name).into();
        let mac_cty: Ident = format!("$cty_{}", written_name).into();

        // Generate the assertion to check that the size and align of the types
        // match before calling.
        let (size, align) = size_data[i + 1];
        let sizeof_msg = format!("size_of for argument `{}` does not match between c++ and \
                                  rust",
                                 &capture.name);
        let alignof_msg = format!("align_of for argument `{}` does not match between c++ and \
                                   rust",
                                  &capture.name);
        let assertion = quote!{
            // Perform a compile time check that the sizes match. This should be
            // a no-op.
            ::std::mem::forget(
                ::std::mem::transmute::<_, [u8; #size]>(
                    ::std::ptr::read(&#mac_name)));

            // NOTE: Both of these calls should be dead code in opt builds.
            assert!(::std::mem::size_of_val(&#mac_name) == #size,
                    #sizeof_msg);
            assert!(::std::mem::align_of_val(&#mac_name) == #align,
                    #alignof_msg);
        };

        let mb_mut = if capture.mutable {
            quote!(mut)
        } else {
            quote!()
        };
        let ptr = if capture.mutable {
            quote!(*mut)
        } else {
            quote!(*const)
        };

        extern_params.push(quote!(#written_name : #ptr u8));

        tt_args.push(quote!(#mb_mut #mac_name : ident as #mac_cty : tt));

        call_args.push(quote!({
            #assertion
            &#mb_mut #mac_name as #ptr _ as #ptr u8
        }));
    }

    let extern_name = closure.extern_name();
    let ret_ty = &closure.ret;
    let (ret_size, ret_align) = size_data[0];
    let result = quote! {
        extern "C" {
            fn #extern_name(#(#extern_params),*) -> #ret_ty;
        }

        macro_rules! __cpp_closure_impl {
            (#(#tt_args),*) => {
                {
                    // Perform a compile time check that the sizes match.
                    ::std::mem::forget(
                        ::std::mem::transmute::<_, [u8; #ret_size]>(
                            ::std::mem::uninitialized::<#ret_ty>()));

                    // Perform a runtime check that the sizes match.
                    assert!(::std::mem::size_of::<#ret_ty>() == #ret_size);
                    assert!(::std::mem::align_of::<#ret_ty>() == #ret_align);

                    #extern_name(#(#call_args),*)
                }
            }
        }
    };

    result.to_string().parse().unwrap()
}
