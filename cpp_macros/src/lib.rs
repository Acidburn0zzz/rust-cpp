extern crate synom;

extern crate syn;

#[macro_use]
extern crate quote;

extern crate cpp_common;

extern crate proc_macro;

#[macro_use]
extern crate lazy_static;

use std::env;
use std::path::PathBuf;
use std::process::Command;
use std::collections::HashMap;
use proc_macro::TokenStream;
use cpp_common::{Capture, ClosureSig, parse_sizes_data, parsing};
use syn::visit::Visitor;
use syn::{Ident, Mac};
use quote::Tokens;

lazy_static! {
    static ref OUT_DIR: PathBuf =
        PathBuf::from(env::var("OUT_DIR").expect(r#"
-- rust-cpp fatal error --

The OUT_DIR environment variable was not set.
NOTE: rustc must be run by Cargo."#));

    static ref CPP_DIR: PathBuf = OUT_DIR.join("rust_cpp");

    static ref SIZE_DATA: HashMap<Ident, Vec<(usize, usize)>> = {
        let mut run_cmd = Command::new(CPP_DIR.join("print_sizes"));
        let output = run_cmd.output().expect(r#"
-- rust-cpp fatal error --

Failed to execute the `print_sizes` executable.
NOTE: Did you make sure to add the rust-cpp build script?"#);
        let stdout = String::from_utf8_lossy(&output.stdout);
        if !output.status.success() {
            panic!("Sizes executable has exited with non-zero status code");
        }

        parse_sizes_data(&stdout).into_iter().collect()
    };
}

fn size_assertions(closure: &ClosureSig) -> Tokens {
    let nums = SIZE_DATA.get(&closure.extern_name()).expect(r#"
-- rust-cpp fatal error --

This cpp! macro is not found in the print_sizes macro output!
NOTE: Only cpp! macros found directly in the program source will be parsed -
NOTE: They cannot be generated by macro expansion."#);

    assert!(nums.len() >= 1);
    let return_ty = &closure.ret;
    let (size, align) = nums[0];
    let return_assertion = quote!{
        assert!(::std::mem::size_of::<#return_ty>() == #size,
                "sizeof for return type does not match between c++ and rust");
        assert!(::std::mem::align_of::<#return_ty>() == #align,
                "alignof for return type does not match between c++ and rust");
    };

    let assertions = nums.iter()
        .skip(1)
        .zip(&closure.captures)
        .map(|(&(size, align), ref capture)| {
            let name = &capture.name;
            let sizeof_msg = format!("sizeof for argument `{}` does not match between c++ and \
                                      rust",
                                     name);
            let alignof_msg = format!("alignof for argument `{}` does not match between c++ and \
                                       rust",
                                      name);
            quote! {
                assert!(::std::mem::size_of_val(#name) == #size, #sizeof_msg);
                assert!(::std::mem::align_of_val(#name) == #align, #alignof_msg);
            }
        })
        .collect::<Vec<_>>();
    quote!(#return_assertion #(#assertions)*)
}

#[proc_macro_derive(__cpp_internal_closure)]
pub fn expand_internal(input: TokenStream) -> TokenStream {
    let source = input.to_string();
    let ast = syn::parse_derive_input(&source).unwrap();

    let mut visitor = Handle { closure: None };
    visitor.visit_derive_input(&ast);
    let closure = visitor.closure.unwrap();

    let ty_params = closure.captures
        .iter()
        .map(|&Capture { ref name, .. }| -> Ident { format!("TypeOf_{}", name).into() });

    let wrapper_params = closure.captures.iter().map(|&Capture { mutable, ref name, .. }| {
        let ty_name: Ident = format!("TypeOf_{}", name).into();
        if mutable {
            quote!(#name : &mut #ty_name)
        } else {
            quote!(#name : &#ty_name)
        }
    });

    let extern_params =
        closure.captures.iter().map(|&Capture { mutable, ref name, .. }| if mutable {
            quote!(#name : *mut u8)
        } else {
            quote!(#name : *const u8)
        });

    let args = closure.captures.iter().map(|&Capture { mutable, ref name, .. }| if mutable {
        quote!(#name as *mut _ as *mut u8)
    } else {
        quote!(#name as *const _ as *const u8)
    });

    let assertions = size_assertions(&closure);

    let extern_name = closure.extern_name();
    let ret_ty = &closure.ret;
    let name = &ast.ident;
    let (impl_generics, ty_generics, where_clause) = ast.generics.split_for_impl();
    (quote! {
        impl #impl_generics #name #ty_generics #where_clause {
            #[allow(non_camel_case_types)]
            unsafe fn run<#(#ty_params),*>(#(#wrapper_params),*) -> #ret_ty {
                extern "C" {
                    fn #extern_name(#(#extern_params),*) -> #ret_ty;
                }

                #assertions

                #extern_name(#(#args),*)
            }
        }
    })
        .to_string()
        .parse()
        .unwrap()
}

struct Handle {
    closure: Option<ClosureSig>,
}

impl Visitor for Handle {
    fn visit_mac(&mut self, mac: &Mac) {
        if mac.path.segments.len() != 1 {
            return;
        }
        if mac.path.segments[0].ident.as_ref() == "cpp" {
            assert!(self.closure.is_none());

            let tts = &mac.tts;
            let src = quote!(#(#tts)*).to_string();
            let input = synom::ParseState::new(&src);
            self.closure = Some(parsing::expand_macro(input).expect("cpp! macro").sig);
        }
    }
}
